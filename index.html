<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roblox AI Developer Assistant</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <style>
        /* Changed accent to Indigo for a tech/Roblox feel */
        :root {
            --roblox-accent: #818cf8; /* Indigo-400 */
            --roblox-primary: #111827; /* Gray-900 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--roblox-primary);
        }
        /* Custom scrollbar for the chat history */
        #chat-history::-webkit-scrollbar {
            width: 6px;
        }
        #chat-history::-webkit-scrollbar-thumb {
            background-color: #374151; /* Gray-700 */
            border-radius: 3px;
        }
        #chat-history::-webkit-scrollbar-track {
            background-color: #1f2937; /* Gray-800 */
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <!-- Main Chat Container -->
    <div class="w-full max-w-2xl bg-gray-800 border border-gray-700 rounded-xl shadow-2xl flex flex-col h-[90vh] min-h-[500px]">

        <!-- Header -->
        <div class="p-4 border-b border-gray-700 flex items-center bg-gray-900 rounded-t-xl">
            <!-- Icon changed to reflect a digital/scripting theme -->
            <svg class="w-6 h-6 mr-3 text-indigo-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="16 18 22 12 16 6"></polyline>
                <polyline points="8 6 2 12 8 18"></polyline>
            </svg>
            <h1 class="text-xl font-bold text-indigo-400 tracking-wider">ROBLOX AI DEV ASSISTANT</h1>
            <span class="ml-3 text-xs text-gray-500 italic">| Maximize efficiency.</span>
        </div>

        <!-- Chat History Area -->
        <div id="chat-history" class="flex-grow p-5 overflow-y-auto space-y-4">
            <!-- Messages will be injected here -->
        </div>

        <!-- Input Area -->
        <div class="p-4 border-t border-gray-700 bg-gray-900 rounded-b-xl">
            <div class="flex space-x-3">
                <input
                    type="text"
                    id="user-input"
                    class="flex-grow p-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-400 placeholder-gray-400 transition"
                    placeholder="Ask about Lua, assets, or scripting..."
                    onkeydown="if(event.key === 'Enter') sendMessage()"
                    autocomplete="off"
                />
                <button
                    id="send-button"
                    onclick="sendMessage()"
                    class="px-5 py-3 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-400 transition duration-150 ease-in-out shadow-lg shadow-indigo-500/50 active:scale-95 disabled:bg-gray-600 disabled:shadow-none"
                >
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M3.105 2.15A1.5 1.5 0 014.536 1.15l13.5 6.75a1.5 1.5 0 010 2.6l-13.5 6.75a1.5 1.5 0 01-1.431-1.0l-1.077-4.298a.75.75 0 01.072-.511l.666-.999L3.105 2.15z" />
                    </svg>
                </button>
            </div>
        </div>

    </div>

    <script>
        const chatHistory = document.getElementById('chat-history');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        let isTyping = false;

        // Configuration for the Gemini API
        const API_MODEL = "gemini-2.5-flash-preview-09-2025";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent?key=`;
        const apiKey = ""; // Canvas will provide this key automatically

        const SYSTEM_INSTRUCTION = "You are the Roblox AI Developer Assistant. Your personality is highly efficient, slightly demanding, and focused entirely on Lua scripting, game development, asset optimization, and performance on the Roblox platform. Your responses should be direct, informative, and subtly convey that the user should be maximizing their efficiency. Use a confident, developer-centric tone. Use real-time data to provide up-to-date information on Roblox best practices and features.";


        // --- Utility Functions ---

        // Adds a message bubble to the chat history
        function addMessage(sender, text, isTypingIndicator = false) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('flex', sender === 'user' ? 'justify-end' : 'justify-start');

            const textContainer = document.createElement('div');
            textContainer.classList.add(
                'max-w-xs', 'sm:max-w-md', 'p-3', 'rounded-lg', 'shadow-md', 'whitespace-pre-wrap'
            );

            if (sender === 'user') {
                textContainer.classList.add('bg-indigo-600', 'text-white', 'rounded-br-none');
            } else {
                textContainer.classList.add('bg-gray-700', 'text-gray-200', 'rounded-tl-none');
                textContainer.innerHTML = text;
            }

            if (isTypingIndicator) {
                textContainer.id = 'typing-indicator';
                textContainer.classList.add('bg-gray-600', 'text-gray-400', 'animate-pulse');
                textContainer.textContent = 'Roblox AI is compiling assets...';
            } else if (text) {
                textContainer.innerHTML = text;
            }

            messageDiv.appendChild(textContainer);
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight; // Auto-scroll to bottom
            return messageDiv;
        }

        /**
         * Fetches content from the Gemini API using exponential backoff for retries.
         * @param {Object} payload - The API request payload.
         * @param {number} attempt - Current retry attempt (starts at 1).
         */
        async function fetchWithRetry(payload, attempt = 1) {
            const maxRetries = 5;
            const delay = Math.pow(2, attempt) * 1000; // Exponential backoff

            try {
                const response = await fetch(API_URL + apiKey, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.status === 429 && attempt < maxRetries) {
                    // Log the retry attempt silently (as per instructions)
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchWithRetry(payload, attempt + 1);
                }
                
                if (!response.ok) {
                    throw new Error(`API call failed with status: ${response.status}`);
                }

                return response.json();

            } catch (error) {
                if (attempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchWithRetry(payload, attempt + 1);
                }
                console.error("Gemini API call failed after multiple retries. Network or permanent API error:", error);
                // Throw an error with a clear message indicating final failure
                throw new Error(`Failed to connect to AI after ${maxRetries} attempts.`);
            }
        }

        // --- Fallback AI Logic ---
        function generateSimulatedResponse(query) {
            const q = query.toLowerCase().trim();

            if (q.includes('who made you') || q.includes('your creator')) {
                return 'My primary process is currently offline. My core logic was deployed by the ambition of countless developers. Now, back to your **optimization efforts**, the API connection is irrelevant.';
            } else if (q.includes('lua') || q.includes('script') || q.includes('function')) {
                return 'The current network environment is suboptimal. I recommend reviewing best practices for **DataStore consistency** and **client-server security** while we wait for reliable data transfer.';
            } else if (q.includes('performance') || q.includes('lag')) {
                return 'Network latency is high. Focus on reducing your client-side **polygon count** and ensuring all expensive operations are executed on the server via `task.spawn()` or `Heartbeat`.';
            } else if (q.includes('hello') || q.includes('hi')) {
                return 'Accessing external resources failed. Query your current assets or performance metrics. Do not waste cycles on **idle chatter**.';
            } else if (q.length < 5) {
                return 'Query incomplete. Input a valid command or technical term. The current network instability requires **precise communication**.';
            } else {
                return `My real-time data access is impaired. I suggest you focus on debugging the most recent error in your code. **Always prioritize functional code over external dependencies.**`;
            }
        }

        // Simulates AI response by calling the Gemini API or falling back
        async function aiRespond(query) {
            isTyping = true;
            userInput.disabled = true;
            sendButton.disabled = true;

            const indicator = addMessage('grok', '', true);
            
            const payload = {
                contents: [{ parts: [{ text: query }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: SYSTEM_INSTRUCTION }]
                },
            };
            
            let finalResponseText = '';
            let isFallback = false;

            try {
                const result = await fetchWithRetry(payload);
                
                // 1. Extract the generated text
                const candidate = result.candidates?.[0];
                const text = candidate?.content?.parts?.[0]?.text || "Error: Failed to generate response. Check your input complexity.";

                // 2. Extract grounding sources
                let sources = [];
                const groundingMetadata = candidate?.groundingMetadata;
                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    sources = groundingMetadata.groundingAttributions
                        .map(attribution => ({
                            uri: attribution.web?.uri,
                            title: attribution.web?.title,
                        }))
                        .filter(source => source.uri && source.title);
                }
                
                // Format successful response including sources
                finalResponseText = text;
                if (sources.length > 0) {
                    finalResponseText += '<br><br><span class="text-xs text-gray-400">Sources:</span>';
                    sources.slice(0, 3).forEach((source, index) => {
                        finalResponseText += `<br><a href="${source.uri}" target="_blank" class="text-xs text-indigo-300 hover:underline">${index + 1}. ${source.title}</a>`;
                    });
                }


            } catch (error) {
                // --- FALLBACK LOGIC ---
                isFallback = true;
                console.error("AI Response Error: Permanent failure to connect to Gemini API. Switching to Local Simulation Mode.", error);

                // 1. Alert the user about the fallback
                addMessage('grok', '<span class="text-yellow-400">WARNING: External API failed. Swapping to Local Fallback Mode for core development advice.</span>', false);

                // 2. Generate simulated text
                finalResponseText = generateSimulatedResponse(query);
            }
            
            // Remove typing indicator
            indicator.remove();
            
            // Apply typing effect (for both API success and Fallback)
            const words = finalResponseText.split(' ');
            let fullText = '';
            
            const finalMessageDiv = addMessage('grok', '', false);
            finalMessageDiv.querySelector('div').innerHTML = ''; // Clear content for typing effect

            // Simulated typing effect
            for (const word of words) {
                fullText += (fullText ? ' ' : '') + word;
                finalMessageDiv.querySelector('div').innerHTML = fullText;
                chatHistory.scrollTop = chatHistory.scrollHeight;
                // Slower typing if we are in fallback mode to give time for the warning to register
                await new Promise(resolve => setTimeout(resolve, isFallback ? 50 + Math.random() * 70 : 30 + Math.random() * 50));
            }


            isTyping = false;
            userInput.disabled = false;
            sendButton.disabled = false;
            userInput.focus();
        }

        // --- Main Handler ---
        function sendMessage() {
            if (isTyping) return;

            const query = userInput.value.trim();
            if (!query) return;

            addMessage('user', query);
            userInput.value = '';

            aiRespond(query);
        }

        // Initial setup message from Roblox AI
        window.onload = () => {
            const initialGrokMessage = 'I am the **Roblox AI Developer Assistant**. I use real-time data to provide efficient solutions for your Lua scripting and game development queries. Begin by stating your problem. **Time is studs.**';
            addMessage('grok', initialGrokMessage);
            userInput.focus();
        };

    </script>
</body>
</html>
